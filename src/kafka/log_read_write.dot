digraph log_read_write {
  node[shape=box];
  newrank=true;
  rankdir=LR;
  subgraph cluster_log {
    graph[label="log";fontsize=20;];
  }

  subgraph cluster_channel {
    graph[label="nio.files.FileChannel";fontsize=20;];
    channel_write[label="write"];
  }
  subgraph cluster_record {
    graph[label="record";fontsize=20;];
    batchIterator -> FileLogInputStream -> DefaultRecordBatch;
    batchIterator -> RecordBatchIterator;
  }

  subgraph cluster_FileRecords {
    graph[label="FileRecords";fontsize=20;];
    FileRecords_append[label="append"];
    FileRecords_slice[label="slice"];
    FileRecords_append -> MemoryRecords_writeFullyTo -> channel_write;
    FileRecords_slice -> new_FileRecords -> batchesFrom;
    batchesFrom -> batchIterator;
  }

  subgraph cluster_TimeIndex {
    graph[label="TimeIndex";fontsize=20;];
    timeIndex_maybeAppend[label="maybeAppend"];
    timeIndex_maybeAppend -> mmap;
  }
  subgraph cluster_OffsetIndex {
    graph[label="OffsetIndex";fontsize=20;];
    offsetIndex_append[label="Append"];
    offsetIndex_lookup[label="lookup"];
    offsetIndex_append -> mmap;
    offsetIndex_lookup -> {
      largestLowerBoundSlotFor;
      parseEntry;
    };
    largestLowerBoundSlotFor -> indexSlotRangeFor -> binarySearch;
    searchForOffsetWithSize -> {
      batchesFrom;
      LogOffsetPosition;
    };
  }
  subgraph cluster_Segment {
    graph[label="LogSegment";fontsize=20;];
    segment_append[shape="record";
      label="{{
        append
      }}";
    ];
    segment_append -> {
      FileRecords_append;
      timeIndex_maybeAppend;
      offsetIndex_append;
    }
    segment_read[label="read"];
    segment_read -> {
      FileRecords_slice;
      translateOffset;
    }
    translateOffset -> {
      offsetIndex_lookup;
      searchForOffsetWithSize;
    };
    shouldRoll -> {
      maxSegmentBytes;
      timeWaitedForRoll;
    }
  }

  subgraph cluster_log {
    graph[label="log";fontsize=20;];
    localLog_read[label="read"];
    appendAsLeader -> append; 
    localLog_read -> segment_read;
    append -> {
      maybeRoll;
    }
    maybeRoll -> {
      activeSegment;
      roll;
    }
    roll -> addSegment;
    addSegment -> segments;
    activeSegment[
      fillcolor="#95e1d3"
      style=filled;
      shape=box3d;
      label="activeSegment"
    ];
    segments[
      fillcolor="#95e1d3"
      style=filled;
      shape=box3d;
      label="segments"
    ];
    activeSegment -> segments[color=red];
  }
  maybeRoll -> shouldRoll;
  append -> segment_append;

  subgraph cluster_partition {
    graph[label="partition";fontsize=20;];
    readRecords -> localLog_read;
    appendRecordsToLeader -> appendAsLeader;
  }
}
